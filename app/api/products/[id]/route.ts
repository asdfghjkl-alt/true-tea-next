import { NextRequest, NextResponse } from "next/server";
import { getSession } from "@/lib/session";
import connectToDatabase from "@/lib/mongodb";
import Product from "@/database/product.model";
import { IImage } from "@/database/image.model";
import Category from "@/database/category.model";
import User from "@/database/user.model";
import { uploadImages, deleteImages } from "@/lib/upload";
import Joi from "joi";
import { apiHandler } from "@/lib/api-handler";

// Validation schema (similar to create but relaxed if needed)
// reusing loose structure or redefining
const productEditSchema = Joi.object({
  name: Joi.string().required(),
  nameCN: Joi.string().allow("", null),
  category: Joi.string().required(),
  seqNr: Joi.number().optional(),
  price: Joi.number().min(0).required(),
  discount: Joi.number().min(0).max(100).optional(),
  includeGST: Joi.boolean().optional(),
  unit: Joi.string().required(),
  stock: Joi.number().min(0).required(),
  onShelf: Joi.boolean().optional(),
  region: Joi.string().allow("", null),
  year: Joi.string().allow("", null),
  note: Joi.string().allow("", null),
  imageOrder: Joi.string().optional(), // JSON string
});

export const PUT = apiHandler(
  async (req: NextRequest, { params }: { params: Promise<{ id: string }> }) => {
    try {
      const { id } = await params;
      const session = await getSession();

      // Checks if user is an admin
      if (!session || !session.userData?._id) {
        return NextResponse.json(
          { message: "Unauthorized access" },
          { status: 401 },
        );
      }

      await connectToDatabase();

      const user = await User.findById(session.userData._id);

      // Verify admin status from database
      if (!user || user.admin !== true) {
        return NextResponse.json(
          { message: "Unauthorized access" },
          { status: 403 },
        );
      }

      // Parses the form data
      const formData = await req.formData();
      const body: Record<string, unknown> = {};
      const files: File[] = [];

      // Converts form data into a JSON object
      formData.forEach((value, key) => {
        if (key === "images") {
          if (value instanceof File) {
            files.push(value);
          }
        } else {
          body[key] = value;
        }
      });

      // Validates the form data with joi schema
      const { error, value: validatedData } = productEditSchema.validate(body);
      if (error) {
        return NextResponse.json(
          { message: error.details[0].message },
          { status: 400 },
        );
      }

      // Fetches the category ID by name and finds if it exists
      const foundCategory = await Category.findOne({
        name: validatedData.category,
      });
      if (!foundCategory) {
        return NextResponse.json(
          { message: "Invalid category" },
          { status: 400 },
        );
      }

      // Image logic
      let finalImages: IImage[] = [];
      // Obtains image order generated by the frontend
      const imageOrderStr = validatedData.imageOrder; // Expecting ["url1", "new:0", ...]

      // Fetches the current product to access existing image objects
      const currentProduct = await Product.findById(id);
      if (!currentProduct) {
        return NextResponse.json(
          { message: "Product not found" },
          { status: 404 },
        );
      }

      if (imageOrderStr) {
        const order = JSON.parse(imageOrderStr);

        // Uploads new files from the frontend
        const uploadedNewFiles = await uploadImages(files);

        // Creates a map of existing images for quick lookup for URL to IImage
        const existingImagesMap = new Map<string, IImage>();

        // Adds existing images to the map
        if (currentProduct.images) {
          currentProduct.images.forEach((img: IImage) => {
            if (img.url) {
              existingImagesMap.set(img.url, img);
            }
          });
        }

        // Reconstructs image array from new images and existing images
        for (const item of order) {
          if (typeof item === "string" && item.startsWith("new:")) {
            // It's a marker like "new:0"
            const index = parseInt(item.split(":")[1]);
            if (uploadedNewFiles[index]) {
              finalImages.push(uploadedNewFiles[index]);
            }
          } else {
            // Existing URL from the existing images
            const existingImg = existingImagesMap.get(item);
            if (existingImg) {
              finalImages.push(existingImg);
            } else {
              // Edge case: URL not found in DB, logs it
              console.warn(`Existing image URL not found: ${item}`);
            }
          }
        }
      } else {
        // Fallback if no order provided (shouldn't happen with the frontend)
        // Replace all images with new files
        const uploaded = await uploadImages(files);
        finalImages = [...currentProduct.images, ...uploaded];
      }

      // Ensure at least one image exists
      if (finalImages.length === 0) {
        return NextResponse.json(
          { message: "At least one image is required" },
          { status: 400 },
        );
      }

      // Handle image deletion
      // Fetches the current product to compare images
      if (currentProduct && currentProduct.images) {
        const currentImages = currentProduct.images;

        // Identifies images that are in currentProduct but NOT in finalImages
        // Extracts filenames to allow cloudinary deletion
        const finalImageIds = new Set(
          finalImages.map((img: IImage) => img.filename),
        );

        const imagesToDelete: string[] = [];

        currentImages.forEach((img: IImage) => {
          // If the image is not in the final images array, then it must have been deleted
          if (!finalImageIds.has(img.filename)) {
            imagesToDelete.push(img.filename);
          }
        });

        // Deletes the images from cloudinary if there are images to delete
        if (imagesToDelete.length > 0) {
          await deleteImages(imagesToDelete);
        }
      }

      // Updates Product
      const updateData = {
        ...validatedData,
        categoryId: foundCategory._id,
        images: finalImages, // Replaces previous array
      };

      const updatedProduct = await Product.findByIdAndUpdate(id, updateData);

      if (!updatedProduct) {
        return NextResponse.json(
          { message: "Product not found" },
          { status: 404 },
        );
      }

      return NextResponse.json(
        { message: "Product updated successfully", product: updatedProduct },
        { status: 200 },
      );
    } catch (error) {
      console.error("Error updating product:", error);
      return NextResponse.json(
        { message: "Internal server error" },
        { status: 500 },
      );
    }
  },
);
